# Solution explained. 

In `main.ml`, I use a simple pure OCaml main script to parse the instructions line by line. I leave this intentionally somewhat vague since I think how the parsing works is both obvious and not nearly as interesting as the HDL design. What's important to know is that this file interacts with the Hardcaml circuit by first running a cycle simulation with input at 50, to load this value in the appropriate register, `spec`. Then, inside a function that iterates on the instruction lines parsed into list form, the circuit is simulated for each instruction, preserving value state as an internal register and count state as the primary output. 

The main logical challenge of this problem is, in my opinion, the wrap-around property of the dial. This is simple enough to solve with a chained structure of 2-mux2s. The idea is that, upon adding/subtracting the new instruction to the stored value, we can check if it's out of bounds by either being `>100` or `< 0`, and if it is, subtracting/adding 100 back is a straightforward way of accounting for the wrap-around. Now, of course, we get instructions like `R449` that make doing this just once insufficient. This is where I get a little "gamey" with my solution. I notice that in the provided list of directions, the absolute value of rotations never exceeds 1000 (the actual cap is 900-something). Therefore, at most, we will ever need to repeat the above arithmetic 10 times. So, I apply pivot 10 times, noticing that once the value becomes in bounds, the mux2 is essentially a noop, so this is safe for all inputs. Lastly, we use a second mux and a simple boolean check to add 1 to our count register if result of the above step is 0. And eventually output the final count at the `main.ml` end.
